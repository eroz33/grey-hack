// Commands library for Sh3ll

    import_code("/lib/libs.src")

// ------------------ Special Functions ------------------
// TODO: evaluate if this is needed.

elevateToRoot = function(dirty, rootHash)
    if typeof(dirty) != "map" then return null
    if typeof(rootHash) != "string" then return null

    // Query database and return if found.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        if rootHash != "" then
            m = libs.dbQueryPasswords(rootHash)
            if typeof(m) != "map" then
                // Run decipher on hash.
                print(globals.name + ": <color=yellow>Cracking <b>root</b> hash...</color>")
                password = crypto.decipher(rootHash)
                if not password then
                    print(globals.name + ": <color=red>Cannot decipher password hash.</color>")
                    return null
                end if

                // Write to password database.
                if libs.dbWritePasswords(password) then
                    print(globals.name + ": <color=orange>Password added.</color>")
                    m = {}
                    m["pass"] = password
                    m["hash"] = rootHash
                else
                    print(globals.name + ": <color=white>Password already exists.</color>")
                end if
            else
                print(globals.name + ": <color=yellow>Password found, elevating to root...</color>")
            end if
        else
            print(globals.name + ": <color=yellow>Root hash not found...</color>")
            return null
        end if
    end if

    payload = "if params.len != 1 then exit(""payload: [password]"")" + char(10)
    payload = payload + "shell = get_shell(""root"", params[0])" + char(10)
    payload = payload + "if not shell then exit(""payload: Could not elevate to root."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "interface.shell = shell" + char(10)

    // Create payload source and build.
    path = dirty.folder.path
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    interface = get_custom_object
    interface.shell = null
    dirty.object.launch(path + "/a", m.pass)
    binfile.delete
    return interface.shell
end function

localElevateFromUser = function(dirty)
    payload = "if params.len != 0 then exit(""payload: No arguments needed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "globals.db = interface.db" + char(10)
    payload = payload + "libs = interface.libs" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "libFolder = get_shell.host_computer.File(""/lib"")" + char(10)
    payload = payload + "if not libFolder then exit(""payload: No lib folder"")" + char(10)
    payload = payload + "libfiles = libFolder.get_files" + char(10)
    payload = payload + "if libfiles.len == 0 then exit(""payload: No lib files"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, """")" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    
    // Upload metaxploit.so to remote machine.
    path = dirty.folder.path
    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    filenames = ["payload", "metaxploit.so", "crypto.so"]
    for filename in filenames
        for folder in folders
            file = local.object.host_computer.File(folder + "/" + filename)
            if not file then continue
            local.object.scp(file.path, path, dirty.object)
        end for
    end for

    // Create the source file.
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)

    // Build the source file.
    interface = get_custom_object
    interface.db = globals.db
    interface.libs = libs
    interface.objects = []
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    dirty.object.launch(path + "/a", "")
    objects = interface.objects
    binfile.delete

    // Cleanup
    libs.wipeTool(dirty.object, path)

    // Loop through objects and check for password.
    if objects.len > 0 then
        rootHash = ""
        for object in objects
            if object.user == "guest" then continue
            print("Public IP: " + object.publicip + char(10) + "Local IP: " + object.localip)
            file = libs.navTo(object.object, "/etc/passwd")
            if not file then continue
            if not file.has_permission("r") then
                print(globals.name + ": Permission denied.")
                continue
            end if
            content = file.get_content
            if content.len < 32 then continue
            rootHash = content[content.indexOf("root:")+5:37]
            break
        end for

        // Elevate to root if root hash found.
        shell = elevateToRoot(dirty, rootHash)
        if shell != null then
            // Cleanup of dirty object.
            libs.wipeLog(shell)
        end if
    end if

    return true
end function

localBounce = function(dirty)
    payload = "if params.len != 0 then exit(""payload: No arguments needed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "globals.db = interface.db" + char(10)
    payload = payload + "libs = interface.libs" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "libFolder = get_shell.host_computer.File(""/lib"")" + char(10)
    payload = payload + "if not libFolder then exit(""payload: No lib folder"")" + char(10)
    payload = payload + "libfiles = libFolder.get_files" + char(10)
    payload = payload + "if libfiles.len == 0 then exit(""payload: No lib files"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, """")" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then exit(""payload: Got root hash!"")" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "routers = []" + char(10)
    payload = payload + "devices = get_router.devices_lan_ip" + char(10)
    payload = payload + "for lanip in devices" + char(10)
    payload = payload + "if get_router(lanip) != null or get_switch(lanip) != null then" + char(10)
    payload = payload + "if routers.indexOf(lanip) == null then routers = routers + get_router(lanip).devices_lan_ip" + char(10)
    payload = payload + "end if" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "" + char(10)
    payload = payload + "found = false" + char(10)
    payload = payload + "for lanip in routers" + char(10)
    payload = payload + "for libfile in libfiles" + char(10)
    payload = payload + "objs = libs.localHack(libfile.path, lanip)" + char(10)
    payload = payload + "for obj in objs" + char(10)
    payload = payload + "if obj.user == ""guest"" then continue" + char(10)
    payload = payload + "interface.objects.push(obj)" + char(10)
    payload = payload + "found = true" + char(10)
    payload = payload + "break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)
    payload = payload + "if found then break" + char(10)
    payload = payload + "end for" + char(10)

    // Upload metaxploit.so to remote machine.
    path = dirty.folder.path
    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    filenames = ["payload", "metaxploit.so", "crypto.so"]
    for filename in filenames
        for folder in folders
            file = local.object.host_computer.File(folder + "/" + filename)
            if not file then continue
            local.object.scp(file.path, path, dirty.object)
        end for
    end for

    // Create the source file.
    srcfile = dirty.object.host_computer.File(path + "/a.src")
    if not srcfile then
        dirty.object.host_computer.touch(path, "a.src")
        srcfile = dirty.object.host_computer.File(path + "/a.src")
    end if
    if not srcfile then return false
    srcfile.set_content(payload)

    // Build the source file.
    interface = get_custom_object
    interface.db = globals.db
    interface.libs = libs
    interface.objects = []
    dirty.object.build(path + "/a.src", path)
    srcfile.delete
    binfile = dirty.object.host_computer.File(path + "/a")
    if not binfile then return false

    // Launch the binary file.
    dirty.object.launch(path + "/a", "")
    objects = interface.objects
    binfile.delete

    // Cleanup
    libs.wipeTool(dirty.object, path)

    // Loop through objects and check for password.
    if objects.len > 0 then
        rootHash = ""
        for object in objects
            if object.user == "guest" then continue
            print("Public IP: " + object.publicip + char(10) + "Local IP: " + object.localip)
            file = libs.navTo(object.object, "/etc/passwd")
            if not file then continue
            if not file.has_permission("r") then
                print(globals.name + ": Permission denied.")
                continue
            end if
            content = file.get_content
            if content.len < 32 then continue
            rootHash = content[content.indexOf("root:")+5:37]
            break
        end for

        // Elevate to root if root hash found.
        shell = elevateToRoot(dirty, rootHash)
        if shell != null then
            // Cleanup of dirty object.
            libs.wipeLog(shell)
        end if
    end if

    return true
end function

// ------------------- Shell Commands --------------------

globals.commandsShell = {}

globals.commandsShell["scp"] = { "name": "scp", "desc": "Upload or download from remote system.", "args": "[path | [-d path] | [-u path]]" }
globals.commandsShell["scp"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 and argv.len != 3 then return print(globals.name + ": Does NOT take any arguments.")

    if argv.len == 2 then
        if argv[1].indexOf("/") == 0 then
            result = local.object.scp(argv[1], current.folder.path, current.object)
            if typeof(result) == "string" then return print(globals.name + ": " + result)
        else
            result = local.object.scp(local.folder.path + "/" + argv[1], current.folder.path, current.object)
            if typeof(result) == "string" then return print(globals.name + ": " + result)
        end if
    else
        if argv[1] == "-d" then
            if argv[2].indexOf("/") == 0 then
                result = current.object.scp(argv[2], local.folder.path, local.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            else
                result = current.object.scp(current.folder.path + "/" + argv[2], local.folder.path, local.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            end if
        else if argv[1] == "-u" then
            if argv[2].indexOf("/") == 0 then
                result = local.object.scp(argv[2], current.folder.path, current.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            else
                result = local.object.scp(local.folder.path + "/" + argv[2], current.folder.path, current.object)
                if typeof(result) == "string" then return print(globals.name + ": " + result)
            end if
        end if
    end if
    return true
end function

globals.commandsShell["shell"] = { "name": "shell", "desc": "Execute a shell on remote system.", "args": "" }
globals.commandsShell["shell"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")

    if typeof(current.object) == "shell" then
        current.object.start_terminal
        globals.running = false
    else
        print(globals.name + ": You are NOT in a shell.")
    end if
    return true
end function

globals.commandsShell["upload"] = { "name": "upload", "desc": "Upload this tool with requirements.", "args": "" }
globals.commandsShell["upload"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Has no arguments.")

    folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
    files = ["db", "crypto.so", "metaxploit.so", "sh3ll", "commands.src", "libs.src"]
    for file in files
        for folder in folders
            fileobj = libs.navTo(local.object, folder + "/" + file)
            if not fileobj then continue
            result = local.object.scp(fileobj.path, current.folder.path, current.object)
            if typeof(result) == "string" then print(globals.name + ": Could not upload file " + fileobj.name)
            break
        end for
    end for
    interface = get_custom_object
    interface.local = {}
    interface.local.user = local.user
    interface.local.object = local.object
    interface.local.computer = function
        if typeof(interface.local.object) == "shell" then return interface.local.object.host_computer
        if typeof(interface.local.object) == "computer" then return interface.local.object
        return null
    end function
    interface.local.folder = local.folder
    interface.local.router = local.router
    interface.local.publicip = function
        return interface.local.router.public_ip
    end function
    interface.local.localip = local.computer.local_ip
    interface.crypto = crypto
    interface.dirty = dirtyObjects
    result = current.object.launch(current.folder.path + "/sh", "")
    if typeof(result) == "string" then return print(globals.name + ": Could not launch shell.")
    return true
end function

globals.commandsShell["run"] = { "name": "run", "desc": "Run a program on the current system.", "args": "[path/to/binary] [args]" }
globals.commandsShell["run"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 then return print(globals.name + ": Takes one or more arguments.")
    result = ""
    cmd = argv[1:2].join("")
    if cmd.indexOf("/") == 0 then
        result = current.object.launch(cmd, argv[2:].join(" "))
    else
        folders = ["/bin", current.folder.path]
        for folder in folders
            computer = current.object.host_computer
            file = computer.File(folder + "/" + cmd)
            if not file then continue
            if not file.has_permission("r") and not file.has_permission("x") then continue
            result = current.object.launch(file.path, argv[2:].join(" "))
            break
        end for
    end if
    if typeof(result) == "string" then return print(globals.name + ": " + result)
    return true
end function

globals.commandsShell["elevate"] = { "name": "elevate", "desc": "Priviledge elevation using username and password.", "args": "[user] [pass]" }
globals.commandsShell["elevate"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 then return print(globals.name + ": Takes two arguments.")

    payload = "if params.len != 2 then exit(""elevate: <user> <pass>"")" + char(10)
    payload = payload + "shell = get_shell(params[0], params[1])" + char(10)
    payload = payload + "if not shell then exit(""elevate: Elevation failed."")" + char(10)
    payload = payload + "interface = get_custom_object" + char(10)
    payload = payload + "interface.shell = shell" + char(10)
    current.object.host_computer.touch(current.folder.path, "a.src")
    srcfile = libs.navTo(current.object, current.folder.path + "/a.src")
    if not srcfile then return print(globals.name + ": Could not create source for elevating.")
    srcfile.set_content(payload)
    current.object.build(current.folder.path + "/a.src", current.folder.path, 0)
    binfile = libs.navTo(current.object, current.folder.path + "/a")
    if not binfile then
        srcfile.delete
        return false
    end if
    interface = get_custom_object
    interface.shell = null
    current.object.launch(current.folder.path + "/a", argv[1] + " " + argv[2])
    if interface.shell != null then
        if globals.objects.indexOf(interface.shell) == null then
            localIP = current.localip
            if typeof(interface.shell) == "shell" then localIP = interface.shell.host_computer.local_ip
            if typeof(interface.shell) == "computer" then localIP = interface.shell.local_ip
            shell = {"object": interface.shell, "user": libs.checkUser(interface.shell), "addr": "", "vuln": "", "localip": localIP, "publicip": current.publicip, "router": current.router }
            current.user = shell.user
            current.object = shell.object
            current.computer = function
                if typeof(shell.object) == "shell" then return shell.object.host_computer
                if typeof(shell.object) == "computer" then return shell.object
                return null
            end function
            current.folder = function
                if shell.user == "root" then
                    return libs.navTo(shell.object, "/root")
                else
                    file = libs.navTo(shell.object, "/home/" + shell.user)
                    if file != null then
                        return libs.navTo(shell.object, file.path)
                    end if
                end if
                return libs.toFile(shell.object)
            end function
            current.router = shell.router
            current.publicip = shell.publicip
            current.localip = shell.localip
            globals.objects.push(shell)
            print("<color=white>If you need this object back.</color>\n<color=white>You can select it with the <b>objects</b> command.</color>")
        end if
    end if
    srcfile.delete
    binfile.delete
    return true
end function

// ----------------- Computer Commands -------------------

globals.commandsComputer = {}

globals.commandsComputer["ps"] = { "name": "ps", "desc": "Display process information.", "args": "" }
globals.commandsComputer["ps"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")

    info = "USER PID COMMAND"
    procs = current.computer.show_procs
    for proc in procs.split(char(10))[1:]
        usr = proc.split(" ")[0]
        pid = proc.split(" ")[1]
        cmd = proc.split(" ")[4]
        info = info + char(10) + usr + " " + pid + " " + cmd
    end for
    print(format_columns(info))
    return true
end function

globals.commandsComputer["clear"] = { "name": "clear", "desc": "Clear the terminal screen.", "args": "" }
globals.commandsComputer["clear"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    return clear_screen
end function

globals.commandsComputer["ls"] = { "name": "ls", "desc": "List the current directory or given directory.", "args": "[(opt) path]" }
globals.commandsComputer["ls"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        info = "PERM OWNER GROUP NAME"
        folder = current.folder
        if not folder then
            print(globals.name + ": Not found.")
            return false
        end if
        for file in folder.get_folders + folder.get_files
            info = info + char(10) + file.permissions + " " + file.owner + " " + file.group + " " + file.name
        end for
        return print(format_columns(info))
    else if argv.len == 2 then
        info = "PERM OWNER GROUP NAME"
        folder = null
        if argv[1].indexOf("/") == 0 then
            folder = libs.navTo(current.object, argv[1])
        else
            folder = libs.navTo(current.object, current.folder.path + "/" + argv[1])
        end if
        if not folder then
            print(globals.name + ": Not found.")
            return false
        end if
        for file in folder.get_folders + folder.get_files
            info = info + char(10) + file.permissions + " " + file.owner + " " + file.group + " " + file.name
        end for
        print(format_columns(info))
    else
        print(globals.name + ": Invalid number of arguments.")
        return false
    end if
    return true
end function

globals.commandsComputer["cd"] = { "name": "cd", "desc": "Change to a different directory.", "args": "[(opt) path]" }
globals.commandsComputer["cd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        file = null
        if current.user == "root" then
            file = libs.navTo(current.object, "/root")
        else
            file = libs.navTo(current.object, "/home/" + current.user)
        end if
        if not file then
            print(globals.name + ": Not found.")
            return false
        end if
        current.folder = file
        return print(globals.name + ": Changed directory.")
    else if argv.len == 2 then
        if argv[1] == ".." then
            if current.folder.path != "/" then
                current.folder = current.folder.parent
                print(globals.name + ": Changed directory.")
            else
                print(globals.name + ": Already at root directory.")
            end if
        else
            file = null
            if argv[1].indexOf("/") == 0 then
                file = libs.navTo(current.object, argv[1])
            else
                file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
            end if
            if not file then
                print(globals.name + ": Not found.")
                return false
            end if
            current.folder = file
            print(globals.name + ": Changed directory.")
        end if
    else
        return print(globals.name + ": Invalid number of arguments.")
    end if
    return true
end function

globals.commandsComputer["pwd"] = { "name": "pwd", "desc": "Print working directory.", "args": "" }
globals.commandsComputer["pwd"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 1 then
        print(current.folder.path)
        return true
    end if
    print(globals.name + ": Invalid number of arguments.")
    return false
end function

globals.commandsComputer["rm"] = { "name": "rm", "desc": "Remove the given file or directory.", "args": "[path]" }
globals.commandsComputer["rm"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")

    if argv.len == 2 then
        file = null
        if argv[1].indexOf("/") != 0 then
            file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
        else
            file = libs.navTo(current.object, argv[1])
        end if
        if not file then
            print(globals.name + ": Not found.")
            return false
        end if
        if file.is_folder then
            print(globals.name + ": Cannot remove a directory.")
            return false
        end if
        if file.has_permission("w") then
            if file.delete then
                print(globals.name + ": File not deleted!")
                return false
            end if
            print(globals.name + ": File deleted!")
        else
            print(globals.name + ": Permission denied!")
        end if
    else
        print(globals.name + ": Invalid number of arguments.")
    end if
    return true
end function

globals.commandsComputer["cat"] = { "name": "cat", "desc": "Print the content of given file.", "args": "[path]" }
globals.commandsComputer["cat"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Invalid arguments given.")

    file = null
    if argv[1].indexOf("/") != 0 then
        file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
    else
        file = libs.navTo(current.object, argv[1])
    end if
    if not file then
        print(globals.name + ": Not found.")
        return false
    end if
    if not file.is_folder and file.has_permission("r") then
        print(file.get_content)
    else
        print(globals.name + ": Permission denied!")
    end if
    return true
end function

globals.commandsComputer["touch"] = { "name": "touch", "desc": "Create a blank file.", "args": "[path]" }
globals.commandsComputer["touch"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        object = current.object
        if typeof(current.object) == "shell" then object = current.object.host_computer
        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        object.touch(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
    else
        allFiles = libs.findAll(libs.toFile(current.object))
        if not allFiles then return print(globals.name + ": Not a file object.")
        if allFiles.len == 0 then return print(globals.name + ": No files in root folder.")

        files = libs.findAllWithWrite(allFiles)
        if not files then return print(globals.name + ": Not a list of maps.")
        if files.len == 0 then return print(globals.name + ": Cannot find any files.")

        for f in files
            if f.type == "text" then
                file = f.file
                break
            end if
        end for
        if not file then return print(globals.name + ": File not found.")

        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        result = file.copy(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
    end if
    if not file then
        print(globals.name + ": File not created.")
        return false
    end if
    file.set_content("")
    file.set_owner(current.user)
    file.set_group(current.user)
    file.chmod("u+rwx", false)
    file.chmod("g+rwx", false)
    file.chmod("o+rwx", false)
    print(globals.name + ": File was created.")
    return true
end function

globals.commandsComputer["mkdir"] = { "name": "mkdir", "desc": "Create an empty directory.", "args": "[path]" }
globals.commandsComputer["mkdir"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        object = current.object
        if typeof(current.object) == "shell" then object = current.object.host_computer
        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if

        object.create_folder(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
        if not file then
            print(globals.name + ": Directory not created.")
            return false
        end if
    else
        allFiles = libs.findAll(libs.toFile(current.object))
        if not allFiles then return print(globals.name + ": Not a file object.")
        if allFiles.len == 0 then return print(globals.name + ": No files in root folder.")

        files = libs.findAllWithWrite(allFiles)
        if not files then return print(globals.name + ": Not a list of maps.")
        if files.len == 0 then return print(globals.name + ": Cannot find any files.")

        file = null
        for f in files
            if f.type == "folder" then
                file = f.file
                break
            end if
        end for
        if not file then return print(globals.name + ": File not found.")

        path = ""
        filename = ""
        if argv[1].indexOf("/") == 0 then
            path = parent_path(argv[1])
            filename = argv[1].split("/")[-1]
        else
            if argv[1].indexOf("/") > 0 then
                path = current.folder.path + "/" + parent_path(argv[1])
                filename = argv[1].split("/")[-1]
            else
                path = current.folder.path
                filename = argv[1]
            end if
        end if
        file.copy(path, filename)
        file = libs.navTo(current.object, path + "/" + filename)
        if not file then
            print(globals.name + ": Directory not created.")
            return false
        end if

        files = file.get_folders + file.get_files
        while files.len > 0
            f = files.pull
            f.delete
        end while
    end if
    file.set_owner(current.user)
    file.set_group(current.user)
    file.chmod("u+rwx", true)
    file.chmod("g+rwx", true)
    file.chmod("o+rwx", true)
    print(globals.name + ": Directory was created.")
    return true
end function

globals.commandsComputer["rmdir"] = { "name": "rmdir", "desc": "Remove a directory.", "args": "[path]" }
globals.commandsComputer["rmdir"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    file = null
    if argv[1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[1])
    end if
    if not file then return print(globals.name + ": Directory not found.")
    if not file.is_folder then return print(globals.name + ": Not a directory.")
    if not file.has_permission("w") then return print(globals.name + ": Permission denied.")
    if file.delete then
        print(globals.name + ": Cannot delete directory.")
        return false
    end if
    print(globals.name + ": Directory deleted.")
    return true
end function

globals.commandsComputer["chmod"] = { "name": "chmod", "desc": "Change a file's permissions.", "args": "[(opt) -R] [ugo-/+rwx] [path]" }
globals.commandsComputer["chmod"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 and argv.len != 4 then return print(globals.name + ": Takes two or three arguments.")

    file = null
    if argv[-1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[-1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[-1])
    end if
    if not file then
        print(globals.name + ": File or directory not found.")
        return false
    end if
    result = null
    if argv[1] == "-R" then
        result = file.chmod(argv[-2], true)
    else
        result = file.chmod(argv[-2], false)
    end if
    if result then
        print(globals.name + ": Failed to set permission.")
        return false
    end if
    print(globals.name + ": Permissions set.")
    return true
end function

globals.commandsComputer["chown"] = { "name": "chown", "desc": "Change a file's owner and group.", "args": "[(opt) -R] [user:group] [path]" }
globals.commandsComputer["chown"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 3 and argv.len != 4 then return print(globals.name + ": Takes two or three arguments.")

    file = null
    if argv[-1].indexOf("/") == 0 then
        file = libs.navTo(current.object, argv[-1])
    else
        file = libs.navTo(current.object, current.folder.path + "/" + argv[-1])
    end if
    if not file then
        print(globals.name + ": File or directory not found.")
        return false
    end if
    owner = null
    group = null
    if argv[-2].indexOf(":") > 0 then
        owner = argv[-2].split(":")[0]
        group = argv[-2].split(":")[1]
    end if
    if typeof(owner) != "string" or typeof(group) != "string" then
        print(globals.name + ": Cannot get owner and group, improper formatting.")
        return false
    end if
    if argv[1] == "-R" then
        if file.set_owner(owner, true) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Owner set.")
        end if
        if file.set_group(group, true) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Group set.")
        end if
    else
        if file.set_owner(owner, false) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Owner set.")
        end if
        if file.set_group(group, false) == 0 then
            print(globals.name + ": Failed to set owner.")
            return false
        else
            print(globals.name + ": Group set.")
        end if
    end if
    return true
end function

// ------------------ General Commands -------------------

globals.commands = {}

globals.commands["help"] = { "name": "help", "desc": "Display a list of commands.", "args": "" }
globals.commands["help"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")

    info = typeof(current.object) + " commands:" + "\n"
    info =  info + " === General Commands ==="
    for command in globals.commands
        if command.value.name.len < 6 then
            info = info + char(9) + command.value.name + "  " + char(9) + char(9) + command.value.desc + "\n"
        else
            info = info + char(9) + command.value.name + "  " + char(9) + command.value.desc + "\n"
        end if
    end for

    if typeof(current.object) == "shell" or typeof(current.object) == "computer" then
        info =  info + " === Computer Commands ==="
        for command in globals.commandsComputer
            if command.value.name.len < 6 then
                info = info + char(9) + command.value.name + "  " + char(9) + char(9) + command.value.desc + "\n"
            else
                info = info + char(9) + command.value.name + "  " + char(9) + command.value.desc + "\n"
            end if
        end for
        if typeof(current.object) == "shell" then
            info =  info + " === Shell Commands ==="
            for command in globals.commandsShell
                if command.value.name.len < 6 then
                    info = info + char(9) + command.value.name + "  " + char(9) + char(9) + command.value.desc + "\n"
                else
                    info = info + char(9) + command.value.name + "  " + char(9) + command.value.desc + "\n"
                end if
            end for
        end if
    end if

    print(info)
    return true
end function

globals.commands["ssh"] = { "name": "ssh", "desc": "Connect to remote shell.", "args": "[user@pass] [ip] [(opt) port]" }
globals.commands["ssh"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Takes three arguments one is optional.")

    creds = argv[1].split("@")
    user = creds[0]
    pass = creds[1]

    targetIP = argv[2]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Unknown network address.")
        return false
    end if

    targetPort = 22
    if argv.len > 3 then targetPort = argv[3].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target port has to be a number.")
        return false
    end if
    if targetPort <= 0 or targetPort > 65535 then
        print(globals.name + ": Target port out of range.")
        return false
    end if

    object = get_shell.connect_service(targetIP, targetPort, user, pass, "ssh")
    if typeof(object) != "shell" then
        print(globals.name + ": Cannot connect to ssh service.")
        return false
    end if

    globals.objects.push({"object": object, "user": libs.checkUser(object), "addr": "ssh", "vuln": "ssh", "localip": object.host_computer.local_ip, "publicip": object.host_computer.public_ip, "router": get_router(object.host_computer.public_ip) })
    print("Connection will be stored for future use as an <b>object</b>")
	print("Now connecting . . . ")
	
	// Auto-switch to the new connection
    current.user = user
    current.object = object
    current.computer = object.host_computer
    current.folder = libs.navTo(object, "/home/" + user)
    if user == "root" then current.folder = libs.navTo(object, "/root")
    if not current.folder then current.folder = libs.navTo(object, "/")

    current.router = get_router(object.host_computer.public_ip)
    current.publicip = object.host_computer.public_ip
    current.localip = object.host_computer.local_ip
 
	
    return true
end function

globals.commands["ftp"] = { "name": "ftp", "desc": "Connect to remote ftp shell.", "args": "[user@pass] [ip] [(opt) port]" }
globals.commands["ftp"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Takes three arguments one is optional.")

    creds = argv[1].split("@")
    user = creds[0]
    pass = creds[1]

    targetIP = argv[2]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Unknown network address.")
        return false
    end if

    targetPort = 22
    if argv.len > 3 then targetPort = argv[3].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target port has to be a number.")
        return false
    end if
    if targetPort <= 0 or targetPort > 65535 then
        print(globals.name + ": Target port out of range.")
        return false
    end if

    object = get_shell.connect_service(targetIP, targetPort, user, pass, "ftp")
    if typeof(object) != "shell" then
        print(globals.name + ": Cannot connect to ftp service.")
        return false
    end if

    print("<color=white>Starting ftp shell...</color>")
    object.start_terminal
    return true
end function

globals.commands["link"] = { "name": "link", "desc": "Display IP information.", "args": "" }
globals.commands["link"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")

    if current.computer != null and not current.computer.is_network_active then
        print(globals.name + ": No network connection.")
        return false
    end if

    print("ESSID: " + current.router.essid_name)
    print("BSSID: " + current.router.bssid_name)
    print("Public IP: " + current.publicip)
    print("Local IP: " + current.localip)
    if current.computer != null then
        print("Gateway: " + current.computer.network_gateway)
    else
        print("Gateway: 0.0.0.0")
    end if
    return true
end function

globals.commands["nmap"] = { "name": "nmap", "desc": "Port scanner and database writer.", "args": "[IP] [(opt) Port]" }
globals.commands["nmap"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 or argv.len > 3 then return print(globals.name + ": Invalid arguments given.")

    if argv.len == 2 then
        ret = libs.getPorts(argv[1])
        if not ret then return print(globals.name + ": Network address not found.")
        if ret.ports.len == 0 then return print(globals.name + ": Scan finished. No ports found.")

        info = "PORT STATE SERVICE VERSION LAN"
        for port in ret.ports
            servinfo = ret.router.port_info(port)
            status = "open"

            if not is_lan_ip(ret.targetIP) and port.is_closed then
                status = "closed"
            end if
            info = info + char(10) + port.port_number + " " + status + " " + servinfo + " " + port.get_lan_ip
        end for
        print(format_columns(info))
    else if argv.len == 3 then
        // Load metaxploit.so into memory.
        metaxploit = include_lib("/lib/metaxploit.so")
        if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
        if not metaxploit then exit(globals.name + ": Cannot find metaxploit.so!")

        if argv[2] == "all" then
            if globals.db.folder == null or globals.hasIndex("exploits") then return print(globals.name + ": Not connected to database.")
            ret = libs.getPorts(argv[1])
            if not ret then return print(globals.name + ": Network address not found.")
            if ret.ports.len == 0 then return print(globals.name + ": Scan finished. No ports found.")

            libs.scanPort(metaxploit, ret.targetIP, 0)
            for port in ret.ports
                if not is_lan_ip(ret.targetIP) and port.is_closed then
                    continue
                end if

                libs.scanPort(metaxploit, ret.targetIP, port.port_number)
            end for
        else
            targetPort = argv[2].to_int
            if typeof(targetPort) == "number" then
                if globals.db.folder == null or globals.hasIndex("exploits") then return print(globals.name + ": Not connected to database.")
                targetIP = argv[1]
                if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
                if not is_valid_ip(targetIP) then
                    print(globals.name + ": Target IP not found.")
                    return false
                end if

                libs.scanPort(metaxploit, targetIP, targetPort)
            else
                print(globals.name + ": Port given was not a number.")
                return false
            end if
        end if
    else
        print(globals.name + ": Invalid arguments given.")
    end if
    return true
end function

globals.commands["rhack"] = { "name": "rhack", "desc": "Remote machine exploitation.", "args": "[IP] [Port] [(opt) injectArg]" }
globals.commands["rhack"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 3 or argv.len > 4 then return print(globals.name + ": Invalid arguments given.")

    targetIP = argv[1]
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then
        print(globals.name + ": Target IP not valid.")
        return false
    end if

    injectArg = ""
    if argv.len > 3 then injectArg = argv[3]

    targetPort = argv[2].to_int
    if typeof(targetPort) != "number" then
        print(globals.name + ": Target Port is not a number.")
        return false
    end if
    if targetPort < 0 or targetPort > 65535 then
        print(globals.name + ": Target port is out of range.")
        return false
    end if

    objects = libs.remoteHack(targetIP, targetPort, injectArg)
    if objects.len == 0 then
        print(globals.name + ": No exploits found.")
        return false
    end if

    if objects.len > 0 then
        for object in objects
            dirty = {}
            dirty.user = object.user
            dirty.object = object.object
            dirty.computer = object.object
            if not dirty.computer and typeof(object.object) == "shell" then dirty.computer = object.object.host_computer
            if not dirty.computer and typeof(object.object) == "file" then dirty.computer = null
            dirty.folder = libs.navTo(object.object, "/home/" + object.user)
            if dirty.user == "root" then dirty.folder = libs.navTo(object.object, "/root")
            if not dirty.folder then dirty.folder = libs.navTo(object.object, "/")
            dirty.router = object.router
            dirty.publicip = object.publicip
            dirty.localip = object.localip
            if dirtyObjects.indexOf(dirty) == null then
                dirtyObjects.push(dirty)
            end if
            if globals.objects.indexOf(dirty) == null then
                globals.objects.push(dirty)
            end if
        end for
        print("<color=white>Please use <b>objects</b> command to switch to remote machine.</color>")
    end if
    return true
end function

globals.commands["lhack"] = { "name": "lhack", "desc": "Local machine exploitation.", "args": "[path/to/lib] [(opt) injectArg]" }
globals.commands["lhack"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len < 2 or argv.len > 3 then return print(globals.name + ": Invalid arguments given.")

    injectArg = ""
    if argv.len > 2 then injectArg = argv[2]

    objects = libs.localHack(argv[1], injectArg)
    if objects.len == 0 then
        print(globals.name + ": No exploits found.")
        return false
    end if

    if objects.len > 0 then
        for object in objects
            dirty = {}
            dirty.user = object.user
            dirty.object = object.object
            dirty.computer = object.object
            if not dirty.computer and typeof(object.object) == "shell" then dirty.computer = object.object.host_computer
            if not dirty.computer and typeof(object.object) == "file" then dirty.computer = null
            dirty.folder = libs.navTo(object.object, "/home/" + object.user)
            if dirty.user == "root" then dirty.folder = libs.navTo(object.object, "/root")
            if not dirty.folder then dirty.folder = libs.navTo(object.object, "/")
            dirty.router = object.router
            dirty.publicip = object.publicip
            dirty.localip = object.localip
            if dirtyObjects.indexOf(dirty) == null then
                dirtyObjects.push(dirty)
            end if
            if globals.objects.indexOf(dirty) == null then
                globals.objects.push(dirty)
            end if
        end for
        print("<color=white>Please use <b>objects</b> command to switch to remote machine.</color>")
    end if
    return true
end function

globals.commands["dirty"] = { "name": "dirty", "desc": "List all dirty objects.", "args": "" }
globals.commands["dirty"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if dirtyObjects.len == 0 then return print(globals.name + ": No dirty objects found.")
    i = 0
    info = "ID TYPE ACCESS PUBLIC LOCAL"
    for dirty in dirtyObjects
        info = info + char(10) + str(i) + " " + typeof(dirty.object) + " " + dirty.user + " " + dirty.publicip + " " + dirty.localip
        i = i + 1
    end for
    print(format_columns(info))
    return true
end function

globals.commands["scrub"] = { "name": "scrub", "desc": "Clean up all dirty objects.", "args": "" }
globals.commands["scrub"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if dirtyObjects.len == 0 then return print(globals.name + ": No dirty objects found.")
    print(globals.name + ": <color=white>Scrubbing dirty ojects...</color>")
    while dirtyObjects.len > 0
        dirty = dirtyObjects.pull
        if typeof(dirty.object) == "shell" then
            print(globals.name + ": <color=yellow>Scrubbing dirty shell objects...</color>")
            if dirty.user == "guest" then
                if dirty.router.public_ip == dirty.publicip and dirty.router.local_ip == dirty.localip then
                    // Is a router.
                    if localBounce(dirty) then
                        index = dirtyObjects.indexOf(dirty)
                        if index != null then
                            dirtyObjects.remove(index)
                        end if
                    end if
                else
                    if localElevateFromUser(dirty) then
                        index = dirtyObjects.indexOf(dirty)
                        if index != null then
                            dirtyObjects.remove(index)
                        end if
                    end if
                end if
            else if dirty.user == "root" then
                libs.wipeTool(dirty.object, dirty.folder.path)
                if libs.wipeLog(dirty.object) then
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            else
                // Wipe tool off computer.
                libs.wipeTool(dirty.object, dirty.folder.path)

                // Elevate from user to root.
                file = libs.navTo(dirty.object, "/etc/passwd")
                if not file then return false
                if not file.has_permission("r") then return false
                content = file.get_content
                if content.len < 32 then return false
                rootHash = content[content.indexOf("root:")+5:37]
                shell = elevateToRoot(dirty, rootHash)
                if shell != null then
                    libs.wipeLog(shell)
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            end if
        else
            if dirty.user == "root" then
                print(globals.name + ": <color=yellow>Scrubbing dirty object...</color>")
                // Clean log file.
                if libs.wipeLog(dirty.object) then
                    index = dirtyObjects.indexOf(dirty)
                    if index != null then
                        dirtyObjects.remove(index)
                    end if
                end if
            else
                print(globals.name + ": <color=orange>Removing dirty object, that cannot be scrubbed...</color>")
                index = dirtyObjects.indexOf(dirty)
                if index != null then
                    dirtyObjects.remove(index)
                end if
            end if
        end if
    end while
    return true
end function

globals.commands["objects"] = { "name": "objects", "desc": "Display all objects or select an object.", "args": "[(opt) ID]" }
globals.commands["objects"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes one optional argument.")

    if argv.len == 1 then
        if globals.objects.len == 0 then return print(globals.name + ": No objects found!")
        i = 0
        info = "ID TYPE ACCESS PUBLIC LAN"
        for object in globals.objects
            info = info + char(10) + str(i) + " " + typeof(object.object) + " " + object.user + " " + object.publicip + " " + object.localip
            i = i + 1
        end for
        print(format_columns(info))
    else
        objectid = argv[1].to_int
        if typeof(objectid) == "string" then return print(globals.name + ": Has to be a number.")
        if (objectid < 0 or objectid > (globals.objects.len - 1)) then
            return print(globals.name + ": Object ID out of range.")
        end if
        current.user = globals.objects[objectid].user
        current.object = globals.objects[objectid].object
        current.computer = globals.objects[objectid].object
        if typeof(globals.objects[objectid].object) == "shell" then current.computer = globals.objects[objectid].object.host_computer
        if typeof(globals.objects[objectid].object) == "file" then current.computer = null
        globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/home/" + globals.objects[objectid].user)
        if globals.objects[objectid].user == "root" then globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/root")
        if not globals.objects[objectid].folder then globals.objects[objectid].folder = libs.navTo(globals.objects[objectid].object, "/")
        current.folder = globals.objects[objectid].folder
        current.router = globals.objects[objectid].router
        current.publicip = globals.objects[objectid].publicip
        current.localip = globals.objects[objectid].localip
        if dirtyObjects.indexOf(globals.objects[objectid]) == null then
            dirtyObjects.push(globals.objects[objectid])
        end if
    end if
    return true
end function


globals.commands["decrypt"] = { "name": "decrypt", "desc": "Decrypt a password hash.", "args": "[hash]" }
globals.commands["decrypt"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    // Query database and return if found.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        m = libs.dbQueryPasswords(argv[1])
        if typeof(m) == "map" then
            print("<color=white>Password: " + m.pass + "</color>")
            return true
        end if
    end if

    // Run decipher on hash.
    password = crypto.decipher(argv[1])
    if not password then
        print(globals.name + ": <color=red>Cannot decipher password hash.</color>")
        return false
    end if

    // Write to database.
    if globals.db.folder != null and globals.db.hasIndex("passwords") then
        if libs.dbWritePasswords(password) then
            print(globals.name + ": <color=orange>Password added.</color>")
            print(globals.name + ": <color=white>Password: " + password + "</color>")
            return true
        else
            print(globals.name + ": <color=white>Password already exists.</color>")
        end if
    end if

    return false
end function

globals.commands["dbcreate"] = { "name": "dbcreate", "desc": "Create a database.", "args": "" }
globals.commands["dbcreate"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes no arguments.")
    if libs.dbCheck then
        print("<color=red>Database already exists.")
        return true
    end if
    return libs.dbCreate
end function

globals.commands["dbdelete"] = { "name": "dbdelete", "desc": "Delete an entry from the database.", "args": "[(opt) dbname]" }
globals.commands["dbdelete"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 2 then return print(globals.name + ": Takes one optional argument.")
    if not globals.db.hasIndex("exploits") or (globals.db.hasIndex("exploits") and globals.db.exploits == null) then return print(globals.name + ": Not connected to database.")

    if argv.len == 2 then
        if libs.dbDelete(argv[1]) then
            print("<color=yellow>Database deleted.</color>")
        else
            print("<color=orange>Database failed to delete.</color>")
        end if
    else
        if libs.dbDelete then
            print("<color=yellow>Database deleted.</color>")
        else
            print("<color=orange>Database failed to delete.</color>")
        end if
    end if
    return true
end function

globals.commands["random"] = { "name": "random", "desc": "Get a random IP to hack.", "args": "" }
globals.commands["random"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Takes NO arguments.")

    randomIP = libs.getRandomIP
    if not randomIP then
        print("Cannot get random IP.")
        return false
    end if
    print("Random global IP: " + randomIP)
    return true
end function

globals.commands["local"] = { "name": "local", "desc": "Switch back to local machine.", "args": "" }
globals.commands["local"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if current.publicip == local.publicip and current.localip == local.localip then
        return print(globals.name + ": <color=yellow>Already on <b>local</b> machine.</color>")
    end if
    current.user = local.user
    current.object = local.object
    current.computer = local.computer
    current.folder = local.folder
    current.router = local.router
    current.publicip = local.computer.public_ip
    current.localip = local.computer.local_ip
    return true
end function

globals.commands["remote"] = { "name": "remote", "desc": "Switch back to remote machine.", "args": "" }
globals.commands["remote"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes no arguments.")
    if remote.publicip == local.publicip and remote.localip == local.localip then
        return print(globals.name + ": <color=orange>Not connected to a <b>remote</b> machine.</color>")
    end if
    if current.publicip == remote.publicip and current.localip == remote.localip then
        return print(globals.name + ": <color=yellow>Already on <b>remote</b> machine.</color>")
    end if
    current.user = remote.user
    current.object = remote.object
    current.computer = remote.computer
    current.folder = remote.folder
    current.router = remote.router
    current.publicip = remote.computer.public_ip
    current.localip = remote.computer.local_ip
    return true
end function

globals.commands["clean"] = { "name": "clean", "desc": "Clear the log file.", "args": "" }
globals.commands["clean"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 1 then return print(globals.name + ": Does NOT take any arguments.")
    if current.user != "root" then print(globals.name + ": <color=orange>You must have <b>root</b> access.</color>")

    return libs.wipeLog(current.object)
end function

globals.commands["secure"] = { "name": "secure", "desc": "Secure your local machine or a remote server.", "args": "[type]" }
globals.commands["secure"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")
    if current.user != "root" then return print(globals.name + ": This command requires root priviledges.")

    if argv[1] == "local" then
        rootFolder = libs.navTo(local.object, "/")
        if not rootFolder then
            print(globals.name + ": Root directory not found.")
            return false
        end if
        result1 = rootFolder.set_owner("root", true)
        result2 = rootFolder.set_group("root", true)
        if result1 or result2 then
            print(globals.name + ": Root directory owner and/or group NOT set.")
            return false
        end if
        print(globals.name + ": Root directory owner and/or group set.")
        rootFolder.chmod("o-rwx", true)
        rootFolder.chmod("g-rwx", true)
        rootFolder.chmod("u+rwx", true)
        print(globals.name + ": Permissions set on root directory recursively.")

        filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "sudo", "db", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
        folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), local.folder.path]
        for filename in filenames
            for folder in folders
                file = libs.navTo(local.object, folder + "/" + filename)
                if not file then continue
                file.set_owner("root", false)
                file.set_group("root", false)
                print(globals.name + ": File owner and/or group set on '" + file.name + "'.")
                if file.name == "sudo" then
                    file.chmod("o-rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                else
                    file.chmod("o+rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                end if
                print(globals.name + ": Permissions set on '" + file.name + "'.")
                break
            end for
        end for
        print(globals.name + ": Secured local machine.")
    else if argv[1] == "remote" then
        rootFolder = libs.navTo(current.object, "/")
        if not rootFolder then
            print(globals.name + ": Root directory not found.")
            return false
        end if
        result1 = rootFolder.set_owner("root", true)
        result2 = rootFolder.set_group("root", true)
        if result1 or result2 then
            print(globals.name + ": Root directory owner and/or group NOT set.")
            return false
        end if
        print(globals.name + ": Root directory owner and/or group set.")
        rootFolder.chmod("o-rwx", true)
        rootFolder.chmod("g-rwx", true)
        rootFolder.chmod("u+rwx", true)
        print(globals.name + ": Permissions set on root directory recursively.")

        answer = ""
        while answer != "y" and answer != "Y" and answer != "n" and answer != "N"
            answer = user_input("Do you wish to secure a router (Y/N)? ")
        end while

        filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "payload", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
        if answer == "y" or answer == "Y" then
            filenames = ["Terminal.exe", "AdminMonitor.exe", "ScanLan.exe", "sudo", "metaxploit.so", "crypto.so", program_path.split("/")[-1]]
            print(globals.name + ": Securing router...")
        else
            print(globals.name + ": Securing server...")
        end if

        folders = ["/lib", "/bin", "/usr/bin", parent_path(program_path), current.folder.path]
        for filename in filenames
            for folder in folders
                file = libs.navTo(current.object, folder + "/" + filename)
                if not file then continue
                file.set_owner("root", false)
                file.set_group("root", false)
                print(globals.name + ": File owner and/or group set on '" + file.name + "'.")
                if file.name == "sudo" then
                    file.chmod("o-rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                else
                    file.chmod("o+rx", false)
                    file.chmod("g+rx", false)
                    file.chmod("u+rwx", false)
                end if
                print(globals.name + ": Permissions set on '" + file.name + "'.")
            end for
        end for
        print(globals.name + ": Secured remote machine.")
    else
        print(globals.name + ": Valid types are 'local' or 'remote'.")
        return false
    end if
    return true
end function

globals.commands["whois"] = { "name": "whois", "desc": "Lookup information about an internet address.", "args": "[ip]" }
globals.commands["whois"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    isDomain = false
    targetIP = argv[1]
    if not is_valid_ip(targetIP) then
        targetIP = nslookup(targetIP)
        if not is_valid_ip(targetIP) then
            print(globals.name + ": Invalid IP or domain name.")
            return false
        end if
        isDomain = true
    end if
    if isDomain then
        print("Domain IP: " + targetIP)
    end if
    print(whois(targetIP))
    return true
end function

globals.commands["nslookup"] = { "name": "nslookup", "desc": "Lookup information about a domain.", "args": "[www.domain.com]" }
globals.commands["nslookup"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len != 2 then return print(globals.name + ": Takes one argument.")

    result = nslookup(argv[1])
    if not is_valid_ip(result) then
        print(globals.name + ": Invalid domain name.")
        return false
    end if
    print("Domain Name: " + argv[1] + "\nDomain IP: " + result)
    return true
end function

globals.commands["exit"] = { "name": "exit", "desc": "Exit this shell.", "args": "" }
globals.commands["exit"]["run"] = function(argv = [])
    if typeof(argv) != "list" then return print(globals.name + ": Invalid argument vector given.")
    if argv.len > 1 then return print(globals.name + ": Takes NO arguments.")
    globals.running = false
    return true
end function