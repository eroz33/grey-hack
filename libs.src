// useful functions for Sh3ll

libs = {}

libs["toFile"] = function(anyObject = null)
    if typeof(anyObject) == "shell" then return anyObject.host_computer.File("/")
    if typeof(anyObject) == "computer" then return anyObject.File("/")
    if typeof(anyObject) == "file" then
        while anyObject.path != "/"
            anyObject = anyObject.parent
        end while
        return anyObject
    end if
    return null
end function

libs["navTo"] = function(anyObject, path = "/")
    if typeof(anyObject) != "file" and typeof(anyObject) != "computer" and typeof(anyObject) != "shell" then
        return null
    end if
    if typeof(path) != "string" then return null
    if path.len == 0 then return null
    
    object = libs.toFile(anyObject)
    if not object then return null

    // Trim trailing '/' character(s) from path.
    while (path.len > 1) and (path[-1] == "/")
        path = path[:-1]
    end while

    // Trim starting '/' character(s) from path.
    while (path.len > 1) and (path[0] == "/")
        path = path[1:]
    end while

    if path == "/" then return object
    path = path.split("/")
    for i in path.indexes
        found = false
        if i == (path.len - 1) then
            for file in object.get_folders + object.get_files
                if file.name != path[i] then continue
                return file
            end for
            return null
        end if

        for file in object.get_folders
            if file.name != path[i] then continue
            found = true
            object = file
            break
        end for
        if not found then return null
    end for

    return object
end function

libs["findAll"] = function(fileObject)
    if typeof(fileObject) != "file" then return null
    
    newList = []
    fileList = fileObject.get_folders + fileObject.get_files
    while fileList.len > 0
        file = fileList.pull
        if file.is_folder then fileList = fileList + file.get_folders + file.get_files
        newList.push(file)
    end while
    return newList
end function

libs["findAllWithRead"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("r") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["findAllWithWrite"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("w") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["findAllWithExec"] = function(fileList)
    if typeof(fileList) != "list" then return null

    newList = []
    for file in fileList
        // Check for permissions
        if file.has_permission("x") then
            if file.is_folder then
                newList.push({ "type": "folder", "file": file })
            else if file.is_binary then
                newList.push({ "type": "binary", "file": file })
            else
                newList.push({ "type": "text", "file": file })
            end if
        end if
    end for
    return newList
end function

libs["checkUser"] = function(anyObject)
    file = libs.navTo(anyObject, "/root")
    if file != null then
        if file.has_permission("r") and file.has_permission("w") and file.has_permission("x") then
            return "root"
        end if
    end if
    homeFolder = libs.navTo(anyObject, "/home")
    if homeFolder != null then
        for user in homeFolder.get_folders
            if user.has_permission("r") and user.has_permission("w") and user.has_permission("x") then
                return user.name
            end if
        end for
    end if
    return "guest"
end function

libs["checkIP"] = function(anyObject, targetIP, targetPort, currentRouter)
    if typeof(anyObject) != "shell" and typeof(anyObject) != "computer" and typeof(anyObject) != "file" then return null
    if not is_valid_ip(targetIP) then return null
    if typeof(targetPort) != "number" then return null
    if typeof(currentRouter) != "router" then return null
    if typeof(anyObject) == "shell" then return { "localip": anyObject.host_computer.local_ip, "publicip": anyObject.host_computer.public_ip, "router": get_router(anyObject.host_computer.public_ip) }
    if typeof(anyObject) == "computer" then return { "localip": anyObject.local_ip, "publicip": anyObject.public_ip, "router": get_router(anyObject.public_ip) }
    if is_lan_ip(targetIP) then return { "localip": targetIP, "publicip": currentRouter.public_ip, "router": currentRouter }
    targetRouter = get_router(targetIP)
    if not targetRouter then return null
    targetPortObject = targetRouter.ping_port(targetPort)
    if targetPortObject then return { "localip": targetPortObject.get_lan_ip, "publicip": targetIP, "router": targetRouter }
    return { "localip": targetRouter.local_ip, "publicip": targetIP, "router": targetRouter }
end function

libs["encrypt"] = function(string = "")
    if typeof(string) != "string" then return null
	safe = ""
	//secret = user_input("Secret : ", true)
    for l in string
		safe = safe + bitwise("^",l,"rabbit")
	end for
    return safe
end function

libs["decrypt"] = function(string = "")
    if typeof(string) != "string" then return null
    safe = ""
	//secret = user_input("Secret : ", true)
    for l in string
		safe = safe + bitwise("^",l,"rabbit")
	end for
    return safe
end function

libs["dbCheck"] = function
    payload = local.computer.File(local.folder.path + "/" + globals.db.name)
    if not payload then return false
    globals.db.folder = payload

    for name in globals.db.names
        folder = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + name)
        if not folder then return false
        globals.db[name] = folder
    end for

    return true
end function

libs["dbCreate"] = function
    db = local.computer.File(local.folder.path + "/" + globals.db.name)
    if not db then
        print("<color=yellow>Creating database folder '" + globals.db.name + "'...</color>")
        local.computer.touch(local.folder.path, globals.db.name)
        db = local.computer.File(local.folder.path + "/" + globals.db.name)
        if not db then
            print("<color=red>Folder '" + globals.db.name + "' already created.</color>")
            return false
        else
            print("<color=yellow>Folder '" + globals.db.name + "' created.</color>")
        end if
    end if
    globals.db.folder = db

    for dbname in globals.db.names
        file = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + dbname)
        if not file then
            print("<color=yellow>Creating database folder '" + dbname + "'...</color>")
            local.computer.touch(local.folder.path + "/" + globals.db.name, dbname)
            file = local.computer.File(local.folder.path + "/" + globals.db.name + "/" + dbname)
            if not file then
                print("<color=red>Folder '" + dbname + "' not created.</color>")
                globals.db[dbname] = null
                return false
            else
                print("<color=yellow>Folder '" + dbname + "' created.</color>")
                globals.db[dbname] = file
            end if
        end if
    end for
    
    return true
end function

libs["dbParseToLines"] = function(result = "")
    if typeof(result) != "string" or result == "" then return null
    lines = result.split(";")[:-1]
    converted = []
    for line in lines
        converted.push(line)
    end for
    return converted
end function

libs["dbStringifyExploits"] = function(result = {})
    if typeof(result) != "map" then return ""
    s = ""
    for memory in result.memorys
        for value in memory.value
            s = s + result.name + ":" + result.version + ":" + memory.key + ":" + value + ";"
        end for
    end for
    return s
end function

libs["dbStringifyLines"] = function(result = [])
    if typeof(result) != "list" then return ""
    s = ""
    for line in result
        s = s + line + ";"
    end for
    return s
end function

libs["dbDelete"] = function(dbName = "")
    if dbName == "" then
        if globals.db.folder == null then return false
        globals.db.folder.delete
        globals.db.folder = null
        for dbname in globals.db.names
            globals.db[dbname] = null
        end for
    else
        if not globals.db.hasIndex(dbName) then return false
        if typeof(globals.db[dbName]) != "file" then return false
        globals.db[dbName].delete
        globals.db[dbName] = null
    end if
    return true
end function

libs["dbParseExploits"] = function(result = "", filename = "")
    if typeof(result) != "string" then return null
    if typeof(filename) != "string" then return null
    if result.indexOf(";") == null then return null
    if result.indexOf(":") == null then return null

    exploits = result.split(";")[:-1]
    ret = {}
    ret.memorys = {}

    for exploit in exploits
        v = exploit.split(":")
        ret.name = v[0]
        ret.version = v[1]
        ret.memorys[v[2]] = []
    end for

    for exploit in exploits
        v = exploit.split(":")
        ret.memorys[v[2]].push(v[3])
    end for

    return ret
end function

libs["dbWriteExploits"] = function(result = null)
    if typeof(result) != "map" then return null

    // Get current file for writing.
    name = "exploit" + str(globals.db.exploitFilesCount) + ".db"
    file = local.computer.File(globals.db.exploits.path + "/" + name)
    if not file then
        local.computer.touch(globals.db.exploits.path, name)
        file = local.computer.File(globals.db.exploits.path + "/" + name)
        if not file then false
    end if

    // Get content and check if in database.
    content = libs.decrypt(file.get_content)
	if typeof(content) != "string" then return false
    stringify = libs.dbStringifyExploits(result)
	if typeof(stringify) != "string" then return false

    if content.len + stringify.len <= 160000 then
        // Process lines
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result.name and v[1] == result.version then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    else
        // Get current file for writing.
        globals.db.exploitFilesCount = globals.db.exploitFilesCount + 1
        name = "exploit" + str(globals.db.exploitFilesCount) + ".db"
        file = local.computer.File(globals.db.exploits.path + "/" + name)
        if not file then
            local.computer.touch(globals.db.exploits.path, name)
            file = local.computer.File(globals.db.exploits.path + "/" + name)
            if not file then false
        end if

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    end if

    return true
end function

libs["dbQueryExploits"] = function(libname = "", libver = "", doprint = false)
    if globals.db.folder == null or not globals.db.hasIndex("exploits") then return null

    if libname == "" then
        retrieved = []
        for file in globals.db.exploits.get_files
            data = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(data)
            for line in lines
                v = line.split(":")
                if retrieved.indexOf(v[0]) == null then
                    retrieved.push(v[0])
                end if
            end for
        end for

        for name in retrieved
            print(name)
        end for
    else
        if libver == "" then
            retrieved = []
            for file in globals.db.exploits.get_files
                found = false
                data = libs.decrypt(file.get_content)
                lines = libs.dbParseToLines(data)
                for line in lines
                    v = line.split(":")
                    s = v[0] + ":" + v[1]
                    if v[0] == libname and retrieved.indexOf(s) == null then
                        retrieved.push(s)
                        found = true
                    end if
                end for
                if found then break
            end for

            for line in retrieved
                v = line.split(":")
                print(v[1])
            end for
        else
            converted = []
            for file in globals.db.exploits.get_files
                found = false
                data = libs.decrypt(file.get_content)
                lines = libs.dbParseToLines(data)
                for line in lines
                    v = line.split(":")
                    if v[0] == libname and v[1] == libver then
                        converted.push(line)
                        found = true
                    end if
                end for
                if found then break
            end for

            if doprint then
                for line in converted
                    v = line.split(":")
                    print("  --> " + v[2] + " [" + v[3] + "]")
                end for
            else
                stringify = libs.dbStringifyLines(converted)
                return libs.dbParseExploits(stringify)
            end if
        end if
    end if
    return null
end function

libs["scanLib"] = function(metalib, metax)
    if not metalib then return null
    if not metax then return null

    if globals.db.folder != null and globals.db.hasIndex("exploits") then
        ret = libs.dbQueryExploits(metalib.lib_name, metalib.version)
        if ret != null then return ret
    end if

    ret = {}
    ret.name = metalib.lib_name
    ret.version = metalib.version
    ret.memorys = {}
    memorys = metax.scan(metalib)
    for memory in memorys
        data = metax.scan_address(metalib, memory).split("Unsafe check: ")
        if not data then continue
        ret.memorys[memory] = []
        for line in data
            if line == data[0] then continue
            if line == "" then continue
            value = line[line.indexOf("<b>")+3:line.indexOf("</b>")].replace(char(10), "")
            ret.memorys[memory].push(value)
        end for
    end for

    if globals.db.folder != null and globals.db.hasIndex("exploits") then
        if libs.dbWriteExploits(ret) then
            print("<color=yellow>Library '" + ret.name + "' version " + ret.version + " added.")
        else
            print("<color=orange>Library '" + ret.name + "' version " + ret.version + " already exists.")
        end if
    end if

    return ret
end function

libs["dbStringifyPassword"] = function(result = {})
    if typeof(result) != "map" then return ""
    s = result.pass + ":" + result.hash + ";"
    return s
end function

libs["dbParsePassword"] = function(result = "")
    if typeof(result) != "string" then return null
    if result.indexOf(":") == null then return null

    line = result.split(";")[:-1]
    v = line.split(":")
    ret = {}
    ret["pass"] = v[0]
    ret["hash"] = v[1]
    return ret
end function

libs["dbWritePasswords"] = function(result = "")
    if typeof(result) != "string" then return false

    // Get current file.
    name = "table" + str(globals.db.passwordFilesCount) + ".db"
    file = local.computer.File(globals.db.passwords.path + "/" + name)
    if not file then
        local.computer.touch(globals.db.passwords.path, name)
        file = local.computer.File(globals.db.passwords.path + "/" + name)
        if not file then false
    end if
    
    // Get content and check if in database.
    content = libs.decrypt(file.get_content)
    stringify = libs.dbStringifyPassword({ "pass": result, "hash": md5(result) })
    
    if content.len + stringify.len <= 160000 then
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    else
        globals.db.passwordFilesCount = globals.db.passwordFilesCount + 1
        name = "table" + str(globals.db.passwordFilesCount) + ".db"
        file = local.computer.File(globals.db.passwords.path + "/" + name)
        if not file then
            local.computer.touch(globals.db.passwords.path, name)
            file = local.computer.File(globals.db.passwords.path + "/" + name)
            if not file then false
        end if

        // Get content and check if in database.
        content = libs.decrypt(file.get_content)
        stringify = libs.dbStringifyPassword({ "pass": result, "hash": md5(result) })
        
        lines = libs.dbParseToLines(content)
        for line in lines
            v = line.split(":")
            if v[0] == result then
                return false
            end if
        end for

        // Write content to database.
        content = content + stringify
        content = libs.encrypt(content)
        result = file.set_content(content)
        if typeof(result) == "string" then return false
    end if

    return true
end function

libs["dbQueryPasswords"] = function(phash = "")
    if typeof(phash) != "string" then return null

    if phash == "" then
        for file in globals.db.passwords.get_files
            content = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(content)
            for line in lines
                v = line.split(":")
                print(v[0] + " [" + v[1] + "]")
            end for
        end for
    else
        m = {}
        m["pass"] = ""
        m["hash"] = ""
        for file in globals.db.passwords.get_files
            found = false
            content = libs.decrypt(file.get_content)
            lines = libs.dbParseToLines(content)
            for line in lines
                v = line.split(":")
                if v[1] == phash then
                    m["pass"] = v[0]
                    m["hash"] = v[1]
                    found = true
                    break
                end if
            end for
            if found then break
        end for

        if m.pass != "" and m.hash != "" then
            return m
        end if
    end if
    return null
end function

libs["getPorts"] = function(ip)
    ret = {}
    ret.targetIP = null
    ret.router = null
    ret.ports = null

    targetIP = ip
    if not is_valid_ip(targetIP) then targetIP = nslookup(targetIP)
    if not is_valid_ip(targetIP) then return null

    if is_lan_ip(targetIP) then
        ret.router = get_router
    else
        ret.router = get_router(targetIP)
    end if
    if not ret.router then return null

    if not is_lan_ip(targetIP) then
        ret.ports = ret.router.used_ports
    else
        ret.ports = ret.router.device_ports(targetIP)
    end if
    if typeof(ret.ports) == "string" then return null

    ret.targetIP = targetIP
    return ret
end function

libs["getRandomIP"] = function()
    parts = []
    maxTries = 100
    while maxTries > 0
        parts.push(ceil(rnd * 223))
        parts.push(floor(rnd * 223))
        parts.push(floor(rnd * 223))
        parts.push(floor(rnd * 223))
        ip = parts.join(".")
        if not is_lan_ip(ip) and is_valid_ip(ip) then return ip
        maxTries = maxTries - 1
    end while
    return null
end function

libs["scanPort"] = function(metaxploit, targetIP, targetPort)
    if typeof(metaxploit) != "MetaxploitLib" then return null
    if not is_valid_ip(targetIP) then return null
    if typeof(targetPort) != "number" then return null

    netsession = metaxploit.net_use(targetIP, targetPort)
    if not netsession then
        print(globals.name + ": Cannot get netsession.")
        return null
    end if

    metalib = netsession.dump_lib
    if not metalib then
        print(globals.name + ": Cannot dump lib.")
        return null
    end if

    return libs.scanLib(metalib, metaxploit)
end function

libs["remoteHack"] = function(targetIP, targetPort, injectArg = "")
    if typeof(targetIP) != "string" then return []
    if typeof(targetPort) != "number" then return []
    if typeof(injectArg) != "string" then return []
    if not is_valid_ip(targetIP) then return []

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/payload/metaxploit.so")
    if not metaxploit then
        print(globals.name + ": Cannot find metaxploit.so!")
        return []
    end if
    
    netsession = metaxploit.net_use(targetIP, targetPort)
    if not netsession then return []
    metalib = netsession.dump_lib
    if not metalib then return []
    exploits = libs.scanLib(metalib, metaxploit)
    if not exploits then return []

    objects = []
    for exploit in exploits.memorys
        print("<color=#FF0000>" + exploit.key + "</color>")
        for value in exploit.value
            print(char(9) + "<color=#FFFF00>" + value + "</color>")
            object = metalib.overflow(exploit.key, value, injectArg)
            if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then continue
            compinfo = libs.checkIP(object, targetIP, targetPort, get_router)
            if not compinfo then continue
            if objects.indexOf(object) == null then
                objects.push({"object": object, "user": libs.checkUser(object), "addr": exploit.key, "vuln": value, "localip": compinfo.localip, "publicip": compinfo.publicip, "router": compinfo.router })
            end if
        end for
    end for
    
    return objects
end function

libs["localHack"] = function(libName = "", injectArg = "")
    if typeof(libName) != "string" then return []
    if typeof(injectArg) != "string" then return []

    // Load metaxploit.so into memory.
    metaxploit = include_lib("/lib/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/metaxploit.so")
    if not metaxploit then metaxploit = include_lib(parent_path(program_path) + "/payload/metaxploit.so")
    if not metaxploit then
        print(globals.name + ": Cannot find metaxploit.so!")
        return []
    end if

    metalib = metaxploit.load(libName)
    if not metalib then return []
    exploits = libs.scanLib(metalib, metaxploit)
    if not exploits then return []

    objects = []
    for exploit in exploits.memorys
        print("<color=#FF0000>" + exploit.key + "</color>")
        for value in exploit.value
            print(char(9) + "<color=#FFFF00>" + value + "</color>")
            object = metalib.overflow(exploit.key, value, injectArg)
            if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then continue
            localIP = current.localip
            if typeof(object) == "shell" then localIP = object.host_computer.local_ip
            if typeof(object) == "computer" then localIP = object.local_ip
            if objects.indexOf(object) == null then
                objects.push({"object": object, "user": libs.checkUser(object), "addr": exploit.key, "vuln": value, "localip": localIP, "publicip": current.publicip, "router": current.router })
            end if
        end for
    end for

    return objects
end function

libs["wipeLog"] = function(object)
    if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then return false

    allFiles = libs.findAll(libs.toFile(object))
    if not allFiles then return false
    if allFiles.len == 0 then return false

    files = libs.findAllWithWrite(allFiles)
    if not files then return false
    if files.len == 0 then return false

    file = null
    for f in files
        if f.type == "text" then
            file = f.file
            break
        end if
    end for
    if not file then return false

    result = file.copy("/var", "system.log")
    if typeof(result) == "string" then return false
    file = libs.navTo(object, "/var/system.log")
    if not file then
        print(globals.name + ": <color=orange>Failed to wipe log.</color>")
        return false
    end if
    file.set_content("")
    print(globals.name + ": <color=green>Log cleaned!</color>")
    return true
end function

libs["wipeTool"] = function(object, path = "")
    if typeof(object) != "shell" and typeof(object) != "computer" and typeof(object) != "file" then return false
    if typeof(path) != "string" then return false

    filenames = ["db", "crypto.so", "metaxploit.so", "ScanLan.exe", program_path.split("/")[-1]]
    for filename in filenames
        fileobj = libs.navTo(object, path + "/" + filename)
        if not fileobj then continue
        result = fileobj.delete
        if result == 0 then
            print(globals.name + ": Could not delete '" + filename + "'.")
        else
            print(globals.name + ": File '" + filename + "' wiped.")
        end if
    end for

    return true
end function